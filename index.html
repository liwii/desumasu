<!DOCTYPE html>
<!-- saved from url=(0234)https://itc-lms.ecc.u-tokyo.ac.jp/lms/course/report/submission_download/index.html?reportId=65820&idnumber=202105100710B01&downloadFileName=index.html&objectName=2021%2Ffd%2Fd8%2F1a%2Ffdd81a5d-b22b-4d18-a8f2-31687e2bee59&downloadMode= -->
<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script type='text/javascript' src='http://code.jquery.com/jquery-1.7.2.min.js'></script>
<title>ですます変換</title>
</head>
<body data-new-gr-c-s-check-loaded="14.1018.0" data-gr-ext-installed="" cz-shortcut-listen="true">

<script>
document.oncontextmenu = function() { return false; }
function goodPosition(top, left) {
    var rightEnd = $("#output")[0].getBoundingClientRect().right;
    if(left + 300 > rightEnd) {
        left = rightEnd - 300;
    }
    return {top: top, left: left};
}
//var selectionStart = 0;
//var selectinEnd = 0;
var index = 0;
var lastSelectionRange;
document.onselectionchange = () => {
    // Selection のときに絶対座標を使って上からdivを被せればいい？
    // 選んでるところには被せないように
    // replaceのときはまあなんとかなる
    var selection = document.getSelection();
    if(selection.collapsed || selection.rangeCount == 0) {
        return;
    }
    var selectionRange = selection.getRangeAt(0);
    if(selectionRange.collapsed) {
        return;
    }
    var intersectionWithSpn = false;
    document.querySelectorAll('.spn').forEach(element => {
        if(selectionRange.intersectsNode(element)) intersectionWithSpn = true;
    });
    if(intersectionWithSpn) {
        $("#edit-text-modal").hide();
        return;
    }
    var selectionText = selection.toString();
    $("#edit-span-modal").hide();
    var selectionPosition = selection.getRangeAt(0).getBoundingClientRect();
    var modalPosition =  goodPosition(selectionPosition.bottom, (selectionPosition.right + selectionPosition.left) / 2)
    $("#edit-text-modal").show();
    $("#original-text").val(selectionText);
    $("#new-text").val("");
    $("#edit-text-modal").css(modalPosition);
    lastSelectionRange = selectionRange;
    reOrganizeSelectedRange(selectionRange);
};
outputHistory = []
var rules = {
	"します": "する",
	"ました": "た",
}

function reOrganizeSelectedRange(selectedRange) {
    $(".float").remove();

    var startId = selectedRange.startContainer.parentNode.id;
    var selectedSpan = document.getElementById(startId);
    var selectedText = selectedRange.toString();
    document.querySelectorAll('.nml').forEach(element => {
        var idx = 0;
        var text = element.innerText;
        while(idx < text.length) {
            idx = text.indexOf(selectedText, idx);
            if(idx < 0) break;
            if (element.id == startId && idx == selectedRange.startOffset) {
                idx++;
                continue;
            }
            addCover(element, selectedText, idx);
            idx++;
        }
    });
}

function addCover(element, selectedText, idx) {
    var range = document.createRange();
    var selectedSpanText = element.childNodes[0];
    range.setStart(selectedSpanText, idx);
    range.setEnd(selectedSpanText, idx + selectedText.length);
    var clientRects = range.getClientRects();
    if(clientRects.length == 1) {
        var rect = clientRects[0];
        $("body").append(`<div class="float" style="position: absolute; left:${rect.left}px; top: ${rect.top - 5}px; padding: 0px; background: rgb(255, 255, 255); display: inline-block; z-index: 100;"><font color="blue" style="font-weight: bold;">${selectedText}</font></div>`);
    } else if(clientRects.length == 2) {
        var rect1Chars = Math.floor(clientRects[0].width / (clientRects[0].width + clientRects[1].width) * selectedText.length);
        var rect2Chars = selectedText.length - rect1Chars;
        $("body").append(`<div class="float" style="position: absolute; left:${clientRects[0].left}px; top: ${clientRects[0].top - 5}px; padding: 0px; background: rgb(255, 255, 255); display: inline-block; z-index: 100;"><font color="blue" style="font-weight: bold;">${selectedText.substr(0, rect1Chars)}</font></div>`);
        $("body").append(`<div class="float" style="position: absolute; left:${clientRects[1].left}px; top: ${clientRects[1].top - 5}px; padding: 0px; background: rgb(255, 255, 255); display: inline-block; z-index: 100;"><font color="blue" style="font-weight: bold;">${selectedText.substr(rect1Chars, rect2Chars)}</font></div>`);
    }
}

function undo() {
    if(outputHistory.length == 0) return;
    var lastHtml = outputHistory.pop();
    $("#output").html(lastHtml);
    if(outputHistory.length == 0) {
        $("#undoButton").prop('disabled', true);
    }
}

function showModal(id) {
    $("#edit-text-modal").hide();
    $("#edit-span-modal").toggle();
    if($("#edit-span-modal").is(":visible")) {
        $("#original-span").val($("#" + id).attr("original"));
        $("#new-span").val("");
        var textPosition = $("#" + id).offset();
        textPosition = goodPosition(textPosition.top + 10, textPosition.left + 10);
        textPosition.top += 10;
        textPosition.left += 10;
        $("#edit-span-modal").css(textPosition);
        $("#edit-span-modal").attr("span-id", id);
    }
}

function backToOriginal() {
    outputHistory.push($("#output").html());
    let spanId = $("#edit-span-modal").attr("span-id");
    // 隣り合ったspanと混ぜ合わせる
    var newText = "";
    let now = $("#" + spanId);
    let prev = now.prev();
    if(prev.length > 0) {
        newText += prev.text();
        prev.remove();
    }
    newText += now.attr("original")
    let next = now.next();
    if(next.length > 0) {
        newText += next.text();
        next.remove();
    }
    $("#" + spanId).replaceWith("<span class=\"nml\" id = \"span" + index+ "\">" + newText + "</span>");
    index++;
    $("#edit-span-modal").hide();
    $("#undoButton").prop('disabled', false);
}

function updateHereSpan() {
    outputHistory.push($("#output").html());
    let spanId = $("#edit-span-modal").attr("span-id");
    $("#" + spanId).html("<font color=\"red\">"+$("#new-span").val()+"</font>");
    $("#edit-span-modal").hide();
    $("#undoButton").prop('disabled', false);
}
function updateHereNml() {
    outputHistory.push($("#output").html());
    $("#edit-text-modal").hide();
    let span = lastSelectionRange.startContainer.parentElement;
    let textPrev = span.innerText.substr(0, lastSelectionRange.startOffset);
    let textOriginal = span.innerText.substr(lastSelectionRange.startOffset, lastSelectionRange.endOffset - lastSelectionRange.startOffset);
    let textReplace = $("#new-text").val();
    let textNext = span.innerText.substr(lastSelectionRange.endOffset);
    $(`<span class="nml" id="span${index}"">${textPrev}</span>`).insertAfter("#" + span.id);
    index++;
    $(`<span class="spn" id="span${index}" onclick="showModal(this.id)" original=${textOriginal}><font color="red">${textReplace}<font></span>`).insertAfter("#span" + (index - 1));
    index++;
    $(`<span class="nml" id="span${index}">${textNext}</span>`).insertAfter("#span" + (index - 1));
    index++;
    $("#" + span.id).remove();
    //span.remove();
    $("#undoButton").prop('disabled', false);
}

function highlight(line, index, original){
	return ("<span class=\"spn\" id=\"span"+index+"\" onclick=\"showModal(this.id)\" original=" + original + "><font color=\"red\">"+line+"</font></span>");
}

function textToSpans(text, appliedRules) {
    var output = "<span class=\"nml\" id=\"span" + index + "\">";
    index++;

	for(i=0; i<text.length; i++){
		var rest = text.slice(i, text.length);
		var rule_keys = Object.keys(appliedRules);
        var key_applied = false;
		for(let key of rule_keys) {
			if(rest.startsWith(key)) {
                output += "</span>"
				output += highlight(appliedRules[key], index, key);
                index++;
                output += "<span class=\"nml\" id=\"span" + index + "\">";
                index++;
                i+=key.length - 1;
                key_applied = true;
                break;
			}
		}
        if(!key_applied) {
            output+=text.slice(i, i+1);
        }
	}
    output += "</span>"
    return output
}

function updateAll() {
    outputHistory.push($("#output").html());
    $("#edit-text-modal").hide();
    $(".float").remove();
    let selectedText = lastSelectionRange.toString();
    let newText = $("#new-text").val();
    let appliedRules = {};
    appliedRules[selectedText] = newText;
    document.querySelectorAll(".nml").forEach(span => {
        $("#" + span.id).replaceWith(textToSpans(span.innerText, appliedRules));
    });
    $("#undoButton").prop('disabled', false);
}

function convert(){
	var source = document.getElementById("source").value.replaceAll("\n", "").replaceAll("　", "");
    var output = textToSpans(source, rules);
    document.getElementById('output').innerHTML = output;
}

</script>

<form><textarea id="source" rows="10" cols="100">原文</textarea><br></form>
<button onclick="convert()">変換</button>
<button id="undoButton" onclick="undo()" disabled>一つ戻る</button>
<div id="output">変換後の文章</div>
<div id="edit-span-modal" style="position: absolute; left: 0px; top: 0px; width: 300px; height: 100px; background: rgba(168, 168, 168, 0.9); border:2px black; display: none; z-index: 1000; margin:10px;">
    <div><span>元のテキスト　　</span><input type="text" id="original-span" disabled></div>
    <div><span>変換後のテキスト</span><input type="text" id="new-span"></div>
    <button onclick="backToOriginal()">元に戻す</button>
    <button onclick="updateHereSpan()">ここだけ変換</button>
</div>

<div id="edit-text-modal" style="position: absolute; left: 0px; top: 0px; width: 300px; height: 100px; background: rgba(168, 168, 168, 0.9); border:2px black; display: none; z-index: 1000; margin:10px;">
    <div><span>元のテキスト　　</span><input type="text" id="original-text" disabled></div>
    <div><span>変換後のテキスト</span><input type="text" id="new-text"></div>
    <button onclick="updateHereNml()">ここだけ変換</button>
    <button onclick="updateAll()">全て変換</button>
</div>



</body></html>