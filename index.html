<!DOCTYPE html>
<!-- saved from url=(0234)https://itc-lms.ecc.u-tokyo.ac.jp/lms/course/report/submission_download/index.html?reportId=65820&idnumber=202105100710B01&downloadFileName=index.html&objectName=2021%2Ffd%2Fd8%2F1a%2Ffdd81a5d-b22b-4d18-a8f2-31687e2bee59&downloadMode= -->
<html lang="ja"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<title>ですます変換</title>
</head>
<body data-new-gr-c-s-check-loaded="14.1018.0" data-gr-ext-installed="" cz-shortcut-listen="true">

<script>

var exampleHeaders = [
"ももたろう",
"Japan supercomputer predicts ‘close to zero’ infection risk for 10,000 spectators at National Stadium",
"Japan to allow uterus transplants in clinical research",
"Japan government wants public insurance system to cover advanced infertility treatments",
"Building nuclear reactors not to be mentioned in Japan’s latest energy plan",
"With broadcasting rights fees secured, IOC no longer cares about spectator numbers at venues",
"Troubles linked to crypto-asset investments overseas on the rise"
]
var exampleContents = [
` むかし、むかし、あるところに、おじいさんとおばあさんがありました。まいにち、おじいさんは山へしば刈りに、おばあさんは川へ洗濯に行きました。
　ある日、おばあさんが、川のそばで、せっせと洗濯をしていますと、川上から、大きな桃が一つ、
「ドンブラコッコ、スッコッコ。
ドンブラコッコ、スッコッコ。」
　と流れて来ました。`,
`富岳スーパーコンピューターは、新しいコロナウイルスに対して適切な対策を講じれば、国立競技場の1万人の観客の感染リスクはほぼゼロであると計算しています。

調査結果は火曜日に教育、文化、スポーツ、科学技術省によって発表されました。

国立競技場は東京都新宿区にあり、東京オリンピック・パラリンピックのメイン会場となります。日本の理化学研究所のメンバーを含む専門家チームは、東京の市中感染率は約0.1％であり、スタジアムの1階には10,000人の観客が入場できると推定しました。それらの観客のうちの10人は感染していると推定されました。

チームはスーパーコンピューターに、ウイルスを含む液滴を含む液滴が観客の間でどのように広がるかを計算させました。観客は、マスクを着用し、空いている席で4時間座って、楽しみながら会話しました。

空調システムが設計通りに機能し、観客の後ろから空気が流れると、「ゼロに近い」状態で新たに感染するだろうとコンピューターは判断した。観客の間に空席がなかったとしても、新規の件数は0.08にとどまるという。

しかし、正面から観客に向かって空気が流れると、後ろに座っている観客に感染者の飛沫が広がり、感染のリスクが高まることがわかった。観客の間にスペースが確保されていれば、0.23件の新たな感染が発生するが、観客が空席のない状態で近くに座っていると、4.7人に増えるとスーパーコンピューターが判断した。

分析では、新しいコロナウイルスの元の形式の感染力レベルを使用しました。`,
`日本医学会の委員会は、特定の条件下での臨床研究の一環として子宮移植を承認するように設定されており、病気のために子宮がない女性が妊娠して子供を産む可能性がある道を開いています。学んだ。

委員会はこの問題について話し合っており、まもなく報告書を発表する予定です。このような臨床研究を行えば、日本で初めてのことです。

日本では、先天性疾患や癌の手術を受けたため、推定60,000〜70,000人の女性が子宮を持っていません。子宮移植は臓器移植法の対象外であり、脳死を宣告された人から臓器を採取することはできません。

2016年、慶應義塾大学のチームは、子宮なしで生まれたロキタンスキー症候群の女性が親戚から寄贈された子宮を受け取ることができる臨床研究の検討を開始しました。チームは2018年に日本産婦人科学会と日本移植学会に研究計画を提出しました。

両学会は、親団体である日本医学会に検討を依頼した。その委員会は、関連する倫理的および医学的問題に関して2019年から議論を行ってきました。

委員会は、子宮移植は、そのような手術を希望する患者がいる限り、治療の選択肢であるべきだと結論付けた、と情報筋は述べた。報告書は、生体ドナーからの子宮移植を除外すべきではないという見解を示します。

しかし、委員会はまた、そのような手術は原則として脳死したドナーから採取された臓器を含むべきであると決定し、報告書は臓器移植法の改正を要求する、と情報筋によると。

健康な人から子宮が取り除かれるため、生体ドナー移植はドナーに大きな負担をかけます。また、移植後の拒絶反応を抑えるために免疫抑制薬を服用するため、妊娠した場合の胎児への影響も懸念されます。

レポートには、ドナーと患者に十分な情報が提供されていること、ドナーが自発的かつ金銭的な補償なしに臓器を提供することに同意していることなどの条件が含まれます。

最初の子宮移植は2000年にサウジアラビアで行われました。 2020年の時点で世界中で80以上が行われ、そのうち33例、つまり約40％のレシピエントが子供を産むことに成功しました。`,
`政府は、不妊治療の公的医療保険の適用範囲を拡大し、日本生殖医療学会が推奨する治療と検査をガイドラインに含める予定です。

新たに対象となる治療法には、体外受精と男性不妊症を治療するための手術が含まれ、政府は2022年度からの変更を適用することを目指しています。この問題は中央社会保険医療評議会（中京）で議論されます。

先月、医学会は、国内で実施されている不妊治療、検査、投薬を含む113項目を評価し、AからCへの降順のスケールを使用して、それらがどれほど強く推奨されるかを評価しました。強くお勧めします」、「B」または「お勧め」と表示されているものは、原則として公的医療保険の対象となります。

レベルAの項目には、体外受精、精巣から精子を抽出する手術、バイアグラやその他のインポテンス薬を使用した男性不妊治療が含まれます。レベルBには、2回連続して流産した女性を対象とした、流産の予防を目的とした着床前検査が含まれています。

レベルCにランク付けされた治療は、基礎が弱いため、公的医療保険の対象にはなりません。ただし、例外的に、健康保険の対象となる治療と組み合わせて使用​​できる高度な治療とみなされ、その有効性と安全性が検証されます。このエリアには、妊娠する可能性が高い卵子を選択するための特別な装置を使用して、受精卵の成長を経時的に撮影する治療法が含まれています。

これらの治療と検査の公式料金は、来年初めに中央京によって決定されます。

一部の排卵誘発剤は現在、公的医療保険でカバーされていますが、高度な対策はカバーされていません。全国調査によると、体外受精の費用は1ラウンドあたり平均約50万円です。このような治療は、成功するまでに数回の治療が必要になることが多いため、子供を産むのに苦労しているカップルに大きな負担をかけます。

昨年、菅義偉首相は、国の慢性的な少子化と戦うために、排卵誘発剤の保険適用範囲を拡大する方針を発表した。

国立社会保障・人口問題研究所が実施した2015年の調査によると、カップルの約20％が不妊治療または検査を受けていました。`,
`読売新聞の草案によると、今年の夏にまとめる戦略的エネルギー計画では、原子炉の建設や再建については言及されていないが、原子力発電は「持続可能な方法。」

国のエネルギー計画は約3年ごとに見直されます。情報筋によると、新しい原子炉を建設すべきかどうかの決定は、次の審査まで延期される可能性が高い。

読売新聞が入手した計画案は、日本が原子力への依存を可能な限り減らすという既存の声明を維持した。これは、2011年に東京電力ホールディングスの福島第一原子力発電所で災害が発生した後、2014年に最初に含まれました。

原子力に対する国民の信頼を得るのはまだ進行中であり、計画の中で原子炉の建設や再建は言うまでもなく、その決定はおそらくその事実に基づいていた。

現在の計画では、2030年度には原子力がエネルギーミックスの20％から22％を占めると規定されています。

法的に認められている最長60年間、原子炉を運転すれば、2050年には23基の原子炉が運転され、日本の総発電量の約10％から20％を占める可能性があります。したがって、中長期的な使用を視野に入れて、将来的に原子炉の建設と再建のどちらを参照するかは、この夏のエネルギー計画の見直しの重要なポイントの1つでした。

菅義偉首相は、2050年までに温室効果ガス排出量をゼロにするという政府の目標を設定しました。その目標を達成するために、計画では再生可能エネルギーを主要な電源として使用する予定です。

■選挙に目を向ける

今年の秋までに行われる次期衆議院選挙で、新原子炉の建設を問題にしないことが、決定のもう一つの要因であると考えられている。国が安定した電力供給と脱炭素化を同時に実現できるかどうかは不明である。

2050年までに温室効果ガス排出量をゼロにするという菅の目標を達成するためには、大量の二酸化炭素を排出する火力発電への依存を減らすことが不可欠です。代替電源を確保する方法は、エネルギー計画の見直しに関する議論の主要なポイントでした。

2011年の福島第一原発事故以来、政府は新しい原子炉を建設するか、既存の原子炉を再建するかを決定することを延期しました。一部の政府当局者は、決定に時間がかかるほど、建物や再建を青信号にするのが難しくなると述べています。

経済産業省の高官は、「次のレビューは、可能な限り最後の機会になるだろう」と述べた。

しかし、社会では原子力への反対が強いままであるため、多くの与党議員は、エネルギー計画は原子炉の建設や再建について明確な見解を示すべきではないと述べており、この問題が次の衆議院の弱点になることを恐れているようだ。下院選挙。

日曜日の東京都議会議員選挙での与党の闘争も決定の動機となった。

風力や太陽光などの再生可能エネルギーはCO2を排出しませんが、気象条件によって出力が変動します。また、再生可能エネルギーの利用が拡大すると、電気料金が上昇する懸念もあります。

脱炭素化と経済成長のバランスをとる方法についての議論を深めなければ、脱炭素化社会を実現する可能性はさらに後退するでしょう。`,
`首都と近隣の3県で観客なしで東京オリンピック・パラリンピックを開催することが決定された今、国際オリンピック委員会（IOC）は、放映権料が高額であるため、観客をそれほど心配していないようです。その収入の一部は確保されています。

IOCは、ゲーム会場で許可される観客数の問題から安全な距離を保っています。 3月、東京オリンピック・パラリンピック組織委員会が海外からの来場者を受け入れないことを決定したとき、IOCは「日本のパートナーや友人はこの結論に軽く到達しなかった」と述べた。

また、6月には、組織委員会が観客数を1万人に制限することを決定した際に、日本側が設定した方針を支持すると述べた。

「大会が開催されている限り、莫大な放映権料が発生します。したがって、大会が観客と一緒に開催されるかどうか、または何人が許可されるかに関係なく、IOCはそれ自体を経済的に犠牲にする必要はありません」と組織委員会の高官は述べました。

IOCの2019年の財務報告によると、2013年から2016年までの収益は合計57億ドル（約6,300億円）で、その73％が放映権料によるものでした。

一部の米国メディアやその他の情報筋によると、IOCが米国のテレビネットワークNBCと米国市場向けに契約した放映権料は、2014年ソチ冬季オリンピック以降の4つの冬季および夏季オリンピックで43.8億ドル（約4800億円）です。 、および2022年から2032年に開催される予定の6つの冬季および夏季オリンピックで76億5000万ドル（約8400億円）。

昨年春、コロナウイルス感染が急速に拡大し始めたとき、大会主催者としてのIOCは、東京オリンピックとパラリンピックをキャンセルしないと繰り返し宣言しました。大会の中止が回避される可能性が高く、放映権料が確保された今、IOCは批判の中でその姿勢を繰り返す必要がなくなった。

日本側が観客数を調整して大会を開催する意向を表明するたびに、IOCはより自信を持ち、より多くの要求をするようになるでしょう。

主催者に近い筋によると、IOCは「IOCの関係者やスポンサーは「別のカテゴリー」として聴衆に許可される」と要求した。IOCはまた、日本側が「情報筋によると、マラソンや競歩イベントの会場移転の費用を支払うなど、日本でより広く知られているIOCの取り組み」とのことです。

IOCのトーマス・バッハ会長は、「私たちは日本のパートナーや友人の側に肩を並べて立っています」と述べています。

しかし、大会の運営を担当する組織委員会は、IOC、政府、地方自治体の政策や国内外の世論の間に挟まれており、完全なものを描いて提示することはできません。開会式の半月前でも大会がどうなるかを描いた写真。

スギノはジュネーブを拠点としています。`,
`国民生活センターによると、仮想通貨に関連する苦情は過去最高を記録するペースで進んでいるとのことで、暗号資産に関連するトラブルの発生率は増加しています。

同センターは、4月から7月6日までに856回の協議を呼びかけ、2018年度の過去最高の3,455件に近づくペースで進んだと述べた。

特に憂慮すべきは、海外で投資した資金が返還されていない場合です。韓国では、約100人の日本人のグループが、投資された資金を返還していないと主張して、今春、暗号資産オペレーターに対して刑事告発を行いました。

韓国の会社を通じて暗号資産に投資した東京都日野市の47歳の女性は、「私は利益に魅了され、リスクについて十分に考えていませんでした。少なくとも、初期投資を取り戻したいと思います。」

2019年8月、同社の暗号資産ビジネスは、「主な保証」、「紹介に対する報酬」、「ゲームを通じて資産を増やす」などのキャッチフレーズを使用して、有名な投資家のブログで紹介されました。高収益に魅了された女性は、追加の暗号資産を購入しました。

紹介報酬を得るために、女性は会社員の夫52人と父親73人を合計約300万円の投資で連れてきた。スマホ専用アプリでゲームをすることで、1ヶ月で約30万円の収益を上げた。

約4ヶ月後、利益を含めて約760万円の引き出しを試みた。彼女のスマートフォンの画面に「送金手続きが完了しました」という通知が表示されましたが、実際の支払いは行われませんでした。彼女が会社に電子メールを送ったとき、それは問題を調査すると答えました、しかししばらくして、それは彼女に連絡するのをやめました。

インターネットで調べたところ、同じように資金を受け取っていない日本人がたくさんいることがわかりました。今年の3月から4月にかけて、女性を含む約100人の日本人が、韓国の弁護士を通じて韓国の警察に刑事告発を行い、企業幹部などが価値のある暗号資産を返還しなかったことを詐欺やその他の罪で告発した。当時4億円。

国民生活センターによると、海外事業者を通じて暗号資産に投資した人が出金できない場合が多いとのことです。あるケースでは、出会い系アプリで出会った異性の人に、「一緒に暮らせるようにお金が欲しいので、投資してみよう」と誘惑された。

今年４月、金融庁、消費者庁、警察庁は、海外を含む未登録事業者に勧誘された後、暗号資産に投資した人が連絡を失った事例を挙げ、投資家に警告を発した。それら。

「投資家はリスクを十分に考慮し、日本で登録された事業者に対処する必要があります」と国立消費者問題センターでそのような問題を扱う当局者は言いました。`
]

$(document).ready(function() {
    for(var i = 0; i < exampleHeaders.length; i++) {
        $("#select-examples").append(`<div><label><input type="radio" name="example" value="${i}" onclick="radioClicked(this)">${exampleHeaders[i]}</label></div>`);
    }
})

function radioClicked(e) {
    console.log(e.value);
    $("#source").text(exampleContents[parseInt(e.value)]);
}
document.oncontextmenu = function() { return false; }
function goodPosition(top, left) {
    var rightEnd = $("#output")[0].getBoundingClientRect().right;
    if(left + 300 > rightEnd) {
        left = rightEnd - 300;
    }
    return {top: top, left: left};
}
//var selectionStart = 0;
//var selectinEnd = 0;
var index = 0;
var lastSelectionRange;
document.onselectionchange = () => {
    // Selection のときに絶対座標を使って上からdivを被せればいい？
    // 選んでるところには被せないように
    // replaceのときはまあなんとかなる
    var selection = document.getSelection();
    if(selection.collapsed || selection.rangeCount == 0) {
        return;
    }
    var selectionRange = selection.getRangeAt(0);
    if(selectionRange.collapsed) {
        return;
    }
    var intersectionWithSpn = false;
    document.querySelectorAll('.spn').forEach(element => {
        if(selectionRange.intersectsNode(element)) intersectionWithSpn = true;
    });
    if(intersectionWithSpn) {
        $("#edit-text-modal").hide();
        return;
    }
    var selectionText = selection.toString();
    $("#edit-span-modal").hide();
    var selectionPosition = selection.getRangeAt(0).getBoundingClientRect();
    var modalPosition =  goodPosition(selectionPosition.bottom, (selectionPosition.right + selectionPosition.left) / 2)
    $("#edit-text-modal").show();
    $("#original-text").val(selectionText);
    $("#new-text").val("");
    $("#edit-text-modal").css(modalPosition);
    lastSelectionRange = selectionRange;
    reOrganizeSelectedRange(selectionRange);
};
outputHistory = []
var rules = {
	"します": "する",
	"ました": "た",
}

function reOrganizeSelectedRange(selectedRange) {
    $(".float").remove();

    var startId = selectedRange.startContainer.parentNode.id;
    var selectedSpan = document.getElementById(startId);
    var selectedText = selectedRange.toString();
    document.querySelectorAll('.nml').forEach(element => {
        var idx = 0;
        var text = element.innerText;
        while(idx < text.length) {
            idx = text.indexOf(selectedText, idx);
            if(idx < 0) break;
            if (element.id == startId && idx == selectedRange.startOffset) {
                idx++;
                continue;
            }
            addCover(element, selectedText, idx);
            idx++;
        }
    });
}

function addCover(element, selectedText, idx) {
    var range = document.createRange();
    var selectedSpanText = element.childNodes[0];
    range.setStart(selectedSpanText, idx);
    range.setEnd(selectedSpanText, idx + selectedText.length);
    var clientRects = range.getClientRects();
    if(clientRects.length == 1) {
        var rect = clientRects[0];
        $("body").append(`<div class="float" style="position: absolute; left:${rect.left}px; top: ${rect.top - 5}px; padding: 0px; background: rgb(255, 255, 255); display: inline-block; z-index: 100;"><font color="blue" style="font-weight: bold;">${selectedText}</font></div>`);
    } else if(clientRects.length == 2) {
        var rect1Chars = Math.floor(clientRects[0].width / (clientRects[0].width + clientRects[1].width) * selectedText.length);
        var rect2Chars = selectedText.length - rect1Chars;
        $("body").append(`<div class="float" style="position: absolute; left:${clientRects[0].left}px; top: ${clientRects[0].top - 5}px; padding: 0px; background: rgb(255, 255, 255); display: inline-block; z-index: 100;"><font color="blue" style="font-weight: bold;">${selectedText.substr(0, rect1Chars)}</font></div>`);
        $("body").append(`<div class="float" style="position: absolute; left:${clientRects[1].left}px; top: ${clientRects[1].top - 5}px; padding: 0px; background: rgb(255, 255, 255); display: inline-block; z-index: 100;"><font color="blue" style="font-weight: bold;">${selectedText.substr(rect1Chars, rect2Chars)}</font></div>`);
    }
}

function undo() {
    if(outputHistory.length == 0) return;
    var lastHtml = outputHistory.pop();
    $("#output").html(lastHtml);
    if(outputHistory.length == 0) {
        $("#undoButton").prop('disabled', true);
    }
}

function showModal(id) {
    $("#edit-text-modal").hide();
    $("#edit-span-modal").toggle();
    if($("#edit-span-modal").is(":visible")) {
        $("#original-span").val($("#" + id).attr("original"));
        $("#new-span").val("");
        var textPosition = $("#" + id).offset();
        textPosition = goodPosition(textPosition.top + 10, textPosition.left + 10);
        textPosition.top += 10;
        textPosition.left += 10;
        $("#edit-span-modal").css(textPosition);
        $("#edit-span-modal").attr("span-id", id);
    }
}

function backToOriginal() {
    outputHistory.push($("#output").html());
    let spanId = $("#edit-span-modal").attr("span-id");
    // 隣り合ったspanと混ぜ合わせる
    var newText = "";
    let now = $("#" + spanId);
    let prev = now.prev();
    if(prev.length > 0) {
        newText += prev.text();
        prev.remove();
    }
    newText += now.attr("original")
    let next = now.next();
    if(next.length > 0) {
        newText += next.text();
        next.remove();
    }
    $("#" + spanId).replaceWith("<span class=\"nml\" id = \"span" + index+ "\">" + newText + "</span>");
    index++;
    $("#edit-span-modal").hide();
    $("#undoButton").prop('disabled', false);
}

function updateHereSpan() {
    outputHistory.push($("#output").html());
    let spanId = $("#edit-span-modal").attr("span-id");
    $("#" + spanId).html("<font color=\"red\">"+$("#new-span").val()+"</font>");
    $("#edit-span-modal").hide();
    $("#undoButton").prop('disabled', false);
}
function updateHereNml() {
    outputHistory.push($("#output").html());
    $("#edit-text-modal").hide();
    let span = lastSelectionRange.startContainer.parentElement;
    let textPrev = span.innerText.substr(0, lastSelectionRange.startOffset);
    let textOriginal = span.innerText.substr(lastSelectionRange.startOffset, lastSelectionRange.endOffset - lastSelectionRange.startOffset);
    let textReplace = $("#new-text").val();
    let textNext = span.innerText.substr(lastSelectionRange.endOffset);
    $(`<span class="nml" id="span${index}"">${textPrev}</span>`).insertAfter("#" + span.id);
    index++;
    $(`<span class="spn" id="span${index}" onclick="showModal(this.id)" original=${textOriginal}><font color="red">${textReplace}<font></span>`).insertAfter("#span" + (index - 1));
    index++;
    $(`<span class="nml" id="span${index}">${textNext}</span>`).insertAfter("#span" + (index - 1));
    index++;
    $("#" + span.id).remove();
    //span.remove();
    $("#undoButton").prop('disabled', false);
}

function highlight(line, index, original){
	return ("<span class=\"spn\" id=\"span"+index+"\" onclick=\"showModal(this.id)\" original=" + original + "><font color=\"red\">"+line+"</font></span>");
}

function textToSpans(text, appliedRules) {
    var output = "<span class=\"nml\" id=\"span" + index + "\">";
    index++;

	for(i=0; i<text.length; i++){
		var rest = text.slice(i, text.length);
		var rule_keys = Object.keys(appliedRules);
        var key_applied = false;
		for(let key of rule_keys) {
			if(rest.startsWith(key)) {
                output += "</span>"
				output += highlight(appliedRules[key], index, key);
                index++;
                output += "<span class=\"nml\" id=\"span" + index + "\">";
                index++;
                i+=key.length - 1;
                key_applied = true;
                break;
			}
		}
        if(!key_applied) {
            output+=text.slice(i, i+1);
        }
	}
    output += "</span>"
    return output
}

function updateAll() {
    outputHistory.push($("#output").html());
    $("#edit-text-modal").hide();
    $(".float").remove();
    let selectedText = lastSelectionRange.toString();
    let newText = $("#new-text").val();
    rules[selectedText] = newText;
    let appliedRules = {};
    appliedRules[selectedText] = newText;
    document.querySelectorAll(".nml").forEach(span => {
        $("#" + span.id).replaceWith(textToSpans(span.innerText, appliedRules));
    });
    $("#undoButton").prop('disabled', false);
}

function convert(){
	var source = document.getElementById("source").value.replaceAll("\n", "").replaceAll("　", "").replaceAll(" ", "");
    var output = textToSpans(source, rules);
    document.getElementById('output').innerHTML = output;
}

</script>

<h3>ですます変換</h3>
<div><p>「ですます調」の文章から「だである調」の文章への変換を支援するツールです。</p></div>
<div id="select-examples" style="margin-top: 30px; margin-bottom: 30px;"></div>

<form><textarea id="source" rows="10" cols="100">原文</textarea><br></form>
<button onclick="convert()">変換</button>
<button id="undoButton" onclick="undo()" disabled>一つ戻る</button>
<div id="output" style="margin-top: 30px;">変換後の文章</div>
<div id="edit-span-modal" style="position: absolute; left: 0px; top: 0px; width: 300px; height: 100px; background: rgba(168, 168, 168, 0.9); border:2px black; display: none; z-index: 1000; margin:10px;">
    <div><span>元のテキスト　　</span><input type="text" id="original-span" disabled></div>
    <div><span>変換後のテキスト</span><input type="text" id="new-span"></div>
    <button onclick="backToOriginal()">元に戻す</button>
    <button onclick="updateHereSpan()">ここだけ変換</button>
</div>

<div id="edit-text-modal" style="position: absolute; left: 0px; top: 0px; width: 300px; height: 100px; background: rgba(168, 168, 168, 0.9); border:2px black; display: none; z-index: 1000; margin:10px;">
    <div><span>元のテキスト　　</span><input type="text" id="original-text" disabled></div>
    <div><span>変換後のテキスト</span><input type="text" id="new-text"></div>
    <button onclick="updateHereNml()">ここだけ変換</button>
    <button onclick="updateAll()">全て変換</button>
</div>



</body></html>